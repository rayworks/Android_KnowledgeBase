# Chap 11

## Thread-Specific Storage Pattern

### 介绍

按字面上意思是指，每个线程特有的存储空间。它是一种即使只有一个入口，也会在内部为每个线程分配特有的存储空间的模式。

### java.lang.ThreadLocal 类

即线程局部存储。泛型类 `ThreadLocal` 的大致声明如下：

``` java
public class ThreadLocal<T> {
  public void set(T value) {
    ...
  }

  public T get() {
    ...
  }
  // ...
}

```

其中的set方法，用于将通过参数接收的实例与调用该方法的线程（当前线程）对应存储起来。这里的存储的对象可以通过get方法获取。

get方法获取与当前线程对应的实例。该方法返回之前通过set方法存储的实例，如果之前一直都没有调用过set方法，则get返回的是 `null`。


### 拓展

* 局部变量与ThreadLocal类

  线程本来都有自己特有的存储空间，即用于保存方法的局部变量的栈。方法中定义的局部变量属于该线程特有，其它线程无法访问它们。但是这些变量在方法调用结束后就会消失。而ThreadLocal 则与方法调用无关，它是一个为线程分配特有的存储空间的类。

* 保存线程特有信息的位置

  * 在线程外保存

    将线程的特有信息保存在线程外部（e.g. ThreadLocal）。随之而来的结果是可能会造成线程的代码变得难以理解。

  * 在线程内保存

    即在线程类中声明的字段，该字段就是线程内部特有的信息。采用这种方法，以后变更信息时不可避免地要修改线程类本身。

* 不必担心其它线程访问

  Thread specific storage是线程特有的存储空间。这一模式为我们提供了一种以线程为key键值，让每个线程只访问它特有的对象的机制。该对象是以线程为单位保存的，不用担心其它线程会访问。

  一般的多线程中我们是为了保护某种被共享的东西才执行的互斥处理，Thread specific storage 模式中因为不存在被共享的内容，所以表现上看不到互斥处理。

* 吞吐量的提高很大程度上取决于实现方式
  
  与强调吞吐量相比，Thread specific storage模式更看重下述的可复用性：

  * 不改变结构即可实现

  * 没有显式的互斥处理，减小了编程时出错可能性

* 上下文的风险

  Thread specific storage中 类似 `ThreadLocal` 的角色会自动判断当前的线程，即中间省略了线程相关信息的参数传递，这也相当于在程序中引入了上下文（Context）。上下文虽然使用方便但也有一定的危险性，因为开发者看不到处理中所使用的信息。

  上下文的概念在计算机图像处理中也有应用。计算机图像处理类库方法中，参数的数量一般较多，因为绘图所需要的坐标，颜色，画笔等信息复杂。为减少参数数量，我们需要先定义图像上下文和设备上下文等数据结构，接着告诉类库要调用的方法。上下文使得程序结构变得简单，而它也让开发者难以理清实际处理中到底使用了哪些信息。上下文的危险性与全局变量非常类似。


### 延伸 ： 基于角色与基于任务

* 基于角色的方式
  
  即在表示线程的实例中保存了进行工作所需要的必要信息（上下文，状态），这样可以减轻线程之间的交互信息量。一个线程会使用从其它线程接收到的信息来执行处理，改变自身的内部状态，我们称之为角色（Actor）。

  ``` java
  class Actor extends Thread {
    // internal states
    public void run() {
      // receive info and run tasks, update inner status
    }
  }
  ```

* 基于任务的方式

  基于任务的方式不保存信息（上下文，状态）。像这样在线程之间交互的实例可以称为消息，请求，或是命令，这里我们暂且称之为任务（Task）。由于任务中保存了足够的信息，所以任何线程执行该任务都没有问题。

  使用该方式的典型示例是Worker Thread 模式（第8章）。

  ```java
  class Task implements Runnable {
    // all the necessary info
    public void run {
      // process the content
    }

  }
  ```
  