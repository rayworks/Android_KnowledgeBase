# Chap 6

## Read-Write Lock pattern

### 介绍

当线程“读取”实例的状态时，实例的状态不会变化，实例的状态仅在线程执行“写入”操作的时候才会发生变化。从实例的状态变化的角度来看，“读取”和“写入”是有着本质的区别的。

在 `Read-Write Lock` 模式中“读取”操作和“写入”操作是分开考虑的。在执行读取操作之前，线程必须获取用于读取的锁；而在执行写入操作之前，线程必须获取用于写入的锁。

当线程“读取”实例的状态时，实例的状态不会变化。因此多个线程可以同时读取；但在读取时，其它线程不可以写入。

当线程执行“写入”操作的时候，实例的状态就会变化。因此当有一个线程在写入时，其它线程不可以读取或是写入。

### 示例

引起冲突的情况：

|       | 读取    | 写入 |
| :-----| :----- | :----- |
| 读取   | 无冲突             | “读取”和“写入”的冲突 |
| 写入   | “读取”和“写入”的冲突 | “写入”和“写入”的冲突 |

### 参与的角色

```
---------            ---------------        ---------
Reader      r         SharedResource    w     Writer
         ◇————>       *read()         <————◇
                      *write()
                      -readWriteLock
---------            ---------------        ---------
                           ◇
                           |
                           | Uses ↓
                           ↓
                     ----------------
                     | ReadWriteLock |
                     ----------------
```

### 拓展

* 利用读取操作的线程间不会冲突的特性来提高程序性能

* 适合读取操作耗时的情况

  单纯使用 `single threaded execution` 模式，对于read操作，每次也只能运行一个线程；而如果read操作很耗时，那么使用`Read-Write Lock` 模式比使用`single threaded execution` 模式更加合适。

  但是因为前者比后者更复杂，所以当read操作较为简单时，`single threaded execution` 模式反而更为适用。

* 适合读取频率比写入频率高的情况
  
  `Read-Write Lock` 模式的特点是reader角色之间不会发生冲突，但是，如果写入处理的频率很高，writer角色会频繁停止reader角色的处理，这样就无法体现出该模式的优点了。

* 锁的含义

  `synchronized` 可以用于获取实例的锁。Java的每个实例（object）都持有一个锁，但同一个锁不可以由2个以上的线程同时获取。
  而用于读取的以及用于写入的锁与使用`synchronized` 获取的锁是不一样的。

### 延伸

* java.util.concurrent.locks 包

  包中的 `ReentrantReadWriteLock` 类实现了`ReadWriteLock`接口。其主要特性如下：

  1）公平性

  `ReentrantReadWriteLock` 是可重入的，也就是，Reader角色的线程可以获取“用以写入的锁”，Writer 角色的线程可以获取“用以读取的锁”。
  
  2）锁降级
  
  `ReentrantReadWriteLock` 类可以按以下顺序将“用以写入的锁”降级为“用以读取的锁”。

  ```
  获取用以写入的锁
       ↓
  获取用以读取的锁
       ↓
  释放用以写入的锁
  ```
  但是 “用以读取的锁”不可以升级为“用以写入的锁”。

  3）便捷的方法

  `ReentrantReadWriteLock` 类中提供了获取等待中的线程的个数的方法`getQueueLength`，以及用于检查是否获取了用于写入的锁的方法`isWriteLocked` 等便捷方法。
